package com.atlassian.jira.jql.context;

import com.atlassian.crowd.embedded.api.User;
import com.atlassian.jira.issue.security.IssueSecurityLevel;
import com.atlassian.jira.issue.security.IssueSecuritySchemeManager;
import com.atlassian.jira.jql.operand.JqlOperandResolver;
import com.atlassian.jira.jql.operand.QueryLiteral;
import com.atlassian.jira.jql.operator.OperatorClasses;
import com.atlassian.jira.jql.resolver.IssueSecurityLevelResolver;
import com.atlassian.jira.project.Project;
import com.atlassian.jira.project.ProjectManager;
import com.atlassian.jira.util.InjectableComponent;
import com.atlassian.jira.util.NonInjectableComponent;
import com.atlassian.jira.util.Predicates;
import com.atlassian.jira.util.collect.CollectionBuilder;
import com.atlassian.jira.util.collect.CollectionUtil;
import com.atlassian.query.clause.TerminalClause;
import com.atlassian.query.operator.Operator;
import org.apache.log4j.Logger;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static com.atlassian.jira.util.dbc.Assertions.notNull;

/**
 * A context factory for issue security level clauses. The contexts that are generated by this factory will all be
 * {@link com.atlassian.jira.jql.context.QueryContextElementType#IMPLICIT}. The context will contain any projects
 * that the security level is relevant for (that the user can see) and an
 * {@link com.atlassian.jira.jql.context.AllIssueTypesContext}.
 *
 * @since v4.0
 */
@NonInjectableComponent
public class IssueSecurityLevelClauseContextFactory implements ClauseContextFactory
{
    private static final Logger log = Logger.getLogger(IssueSecurityLevelClauseContextFactory.class);

    private final JqlOperandResolver jqlOperandResolver;
    private final IssueSecuritySchemeManager issueSecuritySchemeManager;
    private final ProjectManager projectManager;
    private final IssueSecurityLevelResolver issueSecurityLevelResolver;

    IssueSecurityLevelClauseContextFactory(final IssueSecurityLevelResolver issueSecurityLevelResolver,
            final JqlOperandResolver jqlOperandResolver,
            final IssueSecuritySchemeManager issueSecuritySchemeManager, final ProjectManager projectManager)
    {
        this.issueSecurityLevelResolver = notNull("issueSecurityLevelResolver", issueSecurityLevelResolver);
        this.jqlOperandResolver = notNull("jqlOperandResolver", jqlOperandResolver);
        this.issueSecuritySchemeManager = notNull("issueSecuritySchemeManager", issueSecuritySchemeManager);
        this.projectManager = notNull("projectManager", projectManager);
    }

    public ClauseContext getClauseContext(final User searcher, final TerminalClause terminalClause)
    {
        // if we have an unsupported operator return the visibility context
        final Operator operator = terminalClause.getOperator();
        if (!isEqualityOperator(operator))
        {
            return ClauseContextImpl.createGlobalClauseContext();
        }
        else
        {
            return getContextFromClause(searcher, terminalClause);
        }
    }

    ClauseContext getContextFromClause(final User searcher, final TerminalClause terminalClause)
    {
        final Set<Project> associatedProjects = getAssociatedProjectsFromClause(searcher, terminalClause);
        if (associatedProjects.isEmpty())
        {
            return ClauseContextImpl.createGlobalClauseContext();
        }
        final Set<ProjectIssueTypeContext> contexts = getContextsForProjects(associatedProjects);
        return contexts.isEmpty() ? ClauseContextImpl.createGlobalClauseContext() : new ClauseContextImpl(contexts);
    }

    /**
     * Builds up a list of associated projects for the specified security levels
     *
     * @param searcher the user performing the search
     * @param terminalClause the clause
     * @return a set of projects associated to the security levels
     */
    Set<Project> getAssociatedProjectsFromClause(final User searcher, final TerminalClause terminalClause)
    {
        final List<IssueSecurityLevel> securityLevels = getSecurityLevelsFromClause(searcher, terminalClause);
        final Set<Project> associatedProjects = new HashSet<Project>();
        for (IssueSecurityLevel securityLevel : securityLevels)
        {
            // if we found a null security level that indicates we had an empty query literal
            // BUT - empty literals do not impact on the context, so ignore
            if (securityLevel != null)
            {
                associatedProjects.addAll(getProjectsForSecurityLevel(securityLevel));
            }
        }
        return associatedProjects;
    }

    /**
     * Note: result may contain nulls if empty query literals were specified in the clause.
     *
     * @param searcher the user performing the search
     * @param terminalClause the terminal clause
     * @return a list of GenericValues representing the issue security levels which the user can see, possibly containing
     * null values if empty literals were specified; never null.
     */
    List<IssueSecurityLevel> getSecurityLevelsFromClause(final User searcher, final TerminalClause terminalClause)
    {
        final List<QueryLiteral> literals = jqlOperandResolver.getValues(searcher, terminalClause.getOperand(), terminalClause);
        if (literals == null)
        {
            return Collections.emptyList();
        }

        final List<IssueSecurityLevel> levels = issueSecurityLevelResolver.getIssueSecurityLevels(searcher, literals);

        //If its negative and there is at least one level, then the actual scope is the negation.
        if (isNegationOperator(terminalClause.getOperator()) && CollectionUtil.contains(levels, Predicates.notNull()))
        {
            //Levels may contain nulls to represent the empty. We essentially want to ignore these since the global
            //context does not play in context calculation. The removeAll essentially ingores nulls since they
            //don't appear in the "allLevels" list.
            List<IssueSecurityLevel> allLevels = issueSecurityLevelResolver.getAllSecurityLevels(searcher);
            allLevels.removeAll(levels);
            return allLevels;
        }
        else
        {
            return levels;
        }
    }

    /**
     * Resolves the projects related to the security level by first retrieving the security scheme and then retrieving
     * it's associated projects.
     *
     * @param securityLevel the security level generic value
     * @return the collection of associated {@link com.atlassian.jira.project.Project}s; never null.
     */
    Collection<Project> getProjectsForSecurityLevel(IssueSecurityLevel securityLevel)
    {
        final Long schemeId = securityLevel.getSchemeId();
        return issueSecuritySchemeManager.getProjectsUsingScheme(schemeId);
    }

    private Set<ProjectIssueTypeContext> getContextsForProjects(final Collection<Project> projects)
    {
        CollectionBuilder<ProjectIssueTypeContext> builder = CollectionBuilder.newBuilder();
        for (Project project : projects)
        {
            builder.add(new ProjectIssueTypeContextImpl(new ProjectContextImpl(project.getId()), AllIssueTypesContext.INSTANCE));
        }
        return builder.asMutableSet();
    }

    private boolean isNegationOperator(final Operator operator)
    {
        return OperatorClasses.NEGATIVE_EQUALITY_OPERATORS.contains(operator);
    }

    private boolean isEqualityOperator(final Operator operator)
    {
        return OperatorClasses.EQUALITY_OPERATORS_WITH_EMPTY.contains(operator);
    }

    /**
     * Convenience factory class for instantiating {@link com.atlassian.jira.jql.context.IssueSecurityLevelClauseContextFactory}
     * so that we don't need to move all the dependencies around.
     */
    @InjectableComponent
    public static class Creator
    {
        private final JqlOperandResolver jqlOperandResolver;
        private final IssueSecuritySchemeManager issueSecuritySchemeManager;
        private final ProjectManager projectManager;
        private final IssueSecurityLevelResolver issueSecurityLevelResolver;

        public Creator(final IssueSecurityLevelResolver issueSecurityLevelResolver,
                final JqlOperandResolver jqlOperandResolver,
                final IssueSecuritySchemeManager issueSecuritySchemeManager, final ProjectManager projectManager)
        {
            this.issueSecurityLevelResolver = notNull("issueSecurityLevelResolver", issueSecurityLevelResolver);
            this.jqlOperandResolver = notNull("jqlOperandResolver", jqlOperandResolver);
            this.issueSecuritySchemeManager = notNull("issueSecuritySchemeManager", issueSecuritySchemeManager);
            this.projectManager = notNull("projectManager", projectManager);
        }

        public IssueSecurityLevelClauseContextFactory create()
        {
            return new IssueSecurityLevelClauseContextFactory(issueSecurityLevelResolver,
                    jqlOperandResolver, issueSecuritySchemeManager, projectManager);
        }
    }
}
