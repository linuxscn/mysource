package com.atlassian.jira.security.xsrf;

import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import com.atlassian.jira.config.properties.JiraSystemProperties;
import com.atlassian.jira.util.collect.CollectionBuilder;
import com.atlassian.jira.web.action.JiraWebActionSupport;

import org.apache.commons.io.IOUtils;
import org.apache.commons.io.LineIterator;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.ofbiz.core.entity.jdbc.interceptors.connection.ConnectionPoolState;
import org.ofbiz.core.entity.jdbc.interceptors.connection.SQLConnectionInterceptor;
import org.slf4j.MDC;

import webwork.action.ActionContext;
import webwork.action.ActionSupport;

/**
 * SQL Interceptor that detects changes to the database that aren't xsrf protected
 *
 * @since v4.1
 */
public class XsrfVulnerabilityDetectionSQLInterceptor implements SQLConnectionInterceptor
{
    private static final Logger log = Logger.getLogger(XsrfVulnerabilityDetectionSQLInterceptor.class);
    private static final String XSRF_VULNERABILITY_DETECTION_SQLINTERCEPTOR_DONE = "XsrfVulnerabilityDetectionSQLInterceptorDone";

    @Override
    public void onConnectionTaken(Connection connection, ConnectionPoolState connectionPoolState)
    {
    }

    @Override
    public void onConnectionReplaced(Connection connection, ConnectionPoolState connectionPoolState)
    {
    }

    public void beforeExecution(final String sqlString, final List<String> parameterValues, final Statement statement)
    {
    }

    public void afterSuccessfulExecution(final String sqlString, final List<String> parameterValues, final Statement statement, final ResultSet resultSet, final int rowsUpdated)
    {
        afterExecutionImpl(sqlString);
    }

    public void onException(final String sqlString, final List<String> parameterValues, final Statement statement, final SQLException sqlException)
    {
        afterExecutionImpl(sqlString);
    }

    private boolean isMutatingSQL(String sql)
    {
        String sqlString = sql.toUpperCase();
        return sqlString.startsWith("INSERT") ||
                sqlString.startsWith("UPDATE") ||
                sqlString.startsWith("DELETE");
    }

    private void afterExecutionImpl(final String sqlString)
    {
        if (JiraSystemProperties.getInstance().isXsrfDiagnostics())
        {
            final String requestURL = MDC.get("jira.request.url");
            if (isMutatingSQL(sqlString))
            {
                HttpServletRequest request = ActionContext.getRequest();
                if (request != null && request.getAttribute(XSRF_VULNERABILITY_DETECTION_SQLINTERCEPTOR_DONE) == null)
                {
                    // setting this into the request will make things a lot faster
                    request.setAttribute(XSRF_VULNERABILITY_DETECTION_SQLINTERCEPTOR_DONE, "true");
                    CallStack callStack = new CallStack();
                    if (callStack.hasMethodsWeAreInterestedIn() && !callStack.isProtectedAction())
                    {
                        log.error("XSRF VULNERABILITY DETECTED");
                        log.error("requestURL: " + requestURL);
                        log.error("sql: " + sqlString);
                        log.error("CallStack:", callStack);
                    }
                }
            }
        }
    }

    static final List<String> methodsToIgnore = CollectionBuilder.list(
            "com.atlassian.sal.jira.lifecycle.JiraLifecycleManager.onJiraStart",
            "com.atlassian.jira.security.login.LoginStoreImpl.recordLoginAttempt",
            "com.atlassian.jira.user.DefaultUserHistoryManager.addItemToHistory");

    static final List<String> actionWhiteList = new ArrayList<String>();

    static
    {
        if (JiraSystemProperties.isXsrfDetectionCheckRequired())
        {
            log.setLevel(Level.INFO);
        }

        LineIterator iterator = IOUtils.lineIterator(
                new InputStreamReader(
                        XsrfVulnerabilityDetectionSQLInterceptor.class.getResourceAsStream("/security/xsrf/xsrf-white-list.txt")
                )
        );
        for (; iterator.hasNext();)
        {
            String line = ((String) iterator.next()).trim();
            if (line.length() > 0 && !line.startsWith("#"))
            {
                actionWhiteList.add(line);
            }
        }
    }

    private static class CallStack extends RuntimeException
    {
        public boolean hasMethodsWeAreInterestedIn()
        {

            for (StackTraceElement element : getStackTrace())
            {
                String method = element.getClassName() + "." + element.getMethodName();
                if (methodsToIgnore.contains(method))
                {
                    return false;
                }
            }

            return true;
        }

        public boolean isProtectedAction()
        {
            boolean isAnnotated = false;

            StackTraceElement elements[] = getStackTrace();
            for (int i = 0; i < elements.length; i++)
            {
                StackTraceElement element = elements[i];
                if (isActionSupport_execute(element))
                {

                    StackTraceElement action = findActionStackTraceElement(elements, i);
                    // in OSGI land its possible that we cant see the method in play so
                    // if we cant access it then we cant check it
                    if (action != null)
                    {

                        final String className = action.getClassName();

                        try
                        {
                            final Class<?> aClass = Class.forName(action.getClassName());
                            final Method method = getMethod(aClass, action.getMethodName());
                            // in OGSI land its possible that we cant see the method in play so
                            // if we cant access it then we cant check it
                            if (method != null)
                            {
                                isAnnotated = method.isAnnotationPresent(RequiresXsrfCheck.class);
                                final String actionMethodName = action.getMethodName();
                                final String actionName = className + "." + actionMethodName;
                                log.info("ACTION: " + actionName + " PROTECTED: " + isAnnotated);

                                final boolean isActionInWhiteList = isActionInWhiteList(aClass);
                                if (!isAnnotated)
                                {
                                    if (isActionInWhiteList)
                                    {
                                        // its mutated something and its in the white list of good actions.  Something is rotten in Denmark!
                                        throw new RuntimeException("XSRF white list failure");
                                    }
                                }
                                else
                                {
                                    if (!isActionInWhiteList)
                                    {
                                        // its a XSRF annotated method but its not in the white list.  We have missed putting it in the white list
                                        throw new RuntimeException("ACTION: " + actionName + " has XSRF annotated but its not in the whitelist");
                                    }
                                }
                            }
                        }
                        catch (ClassNotFoundException e)
                        {
                            //ignored
                        }
                        break; // out of the loop
                    }
                }
            }
            return isAnnotated;
        }

        private StackTraceElement findActionStackTraceElement(final StackTraceElement[] elements, final int i)
        {
            StackTraceElement foundElement = null;
            // if the next method is ActionSupport.invokeCommand we need to search up the stack trace until we find a doXXXX method
            StackTraceElement element = elements[i - 1];
            if (isActionSupport_invokeCommand(element))
            {
                for (int j = i; j >= 0; j--)
                {
                    element = elements[j];
                    if (isActionDoMethod(element))
                    {
                        foundElement = element;
                        break;
                    }
                }
            }
            return foundElement;
        }

        private boolean isActionSupport_invokeCommand(final StackTraceElement element)
        {
            return ActionSupport.class.getName().equals(element.getClassName()) &&
                    "invokeCommand".equals(element.getMethodName());
        }

        private boolean isActionSupport_execute(final StackTraceElement element)
        {
            return ActionSupport.class.getName().equals(element.getClassName()) &&
                    "execute".equals(element.getMethodName());
        }

        private boolean isActionDoMethod(final StackTraceElement element)
        {
            boolean isok = ActionSupport.class.isAssignableFrom(getClassOfElement(element));
            isok = isok && element.getMethodName().startsWith("do");
            return isok;
        }

        private Class getClassOfElement(final StackTraceElement element)
        {
            try
            {
                return Class.forName(element.getClassName());
            }
            catch (ClassNotFoundException e)
            {
                return e.getClass();
            }
        }

        private boolean isActionInWhiteList(final Class<?> aClass)
        {
            // complex name first
            boolean isActionInWhiteList = actionWhiteList.contains(aClass.getName());
            if (!isActionInWhiteList)
            {
                // simple name last
                isActionInWhiteList = actionWhiteList.contains(aClass.getSimpleName());
            }
            return isActionInWhiteList;
        }

        /**
         * Finds the declared method on the provided class. If the method is not declared on the class, we search
         * recursively up the inheritance hierarchy, stopping at {@link com.atlassian.jira.web.action.JiraWebActionSupport}
         * or {@link Object}.
         *
         * @param clazz      the class
         * @param methodName the method name to find
         *
         * @return the method on the class; null if it could not be found.
         */
        private Method getMethod(final Class<?> clazz, final String methodName)
        {
            try
            {
                return clazz.getDeclaredMethod(methodName);
            }
            catch (NoSuchMethodException e)
            {
                if (clazz.equals(JiraWebActionSupport.class) || clazz.equals(Object.class))
                {
                    return null;
                }
                else
                {
                    return getMethod(clazz.getSuperclass(), methodName);
                }
            }
        }

    }
}
